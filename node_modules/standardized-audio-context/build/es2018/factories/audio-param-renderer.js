export const createAudioParamRenderer = () => {
    const automations = [];
    return {
        record(automation) {
            automations.push(automation);
        },
        replay(audioParam) {
            for (const automation of automations) {
                if (automation.type === 'cancelScheduledValues') {
                    const { cancelTime } = automation;
                    audioParam.cancelScheduledValues(cancelTime);
                }
                else if (automation.type === 'exponentialRampToValue') {
                    const { endTime, value } = automation;
                    audioParam.exponentialRampToValueAtTime(value, endTime);
                }
                else if (automation.type === 'linearRampToValue') {
                    const { endTime, value } = automation;
                    audioParam.linearRampToValueAtTime(value, endTime);
                }
                else if (automation.type === 'setTarget') {
                    const { startTime, target, timeConstant } = automation;
                    audioParam.setTargetAtTime(target, startTime, timeConstant);
                }
                else if (automation.type === 'setValue') {
                    const { startTime, value } = automation;
                    audioParam.setValueAtTime(value, startTime);
                }
                else if (automation.type === 'setValueCurve') {
                    const { duration, startTime, values } = automation;
                    /*
                     * @todo TypeScript can't combine the call signatures of setValueCurveAtTime() of IAudioParam and TNativeAudioParam as
                     * their return types are incompatible.
                     */
                    audioParam.setValueCurveAtTime(values, startTime, duration);
                }
                else {
                    throw new Error("Can't apply an unknown automation.");
                }
            }
        }
    };
};
//# sourceMappingURL=/build/es2018/factories/audio-param-renderer.js.map