export const wrapAudioNodeDisconnectMethod = (nativeAudioNode) => {
    const destinations = new Map();
    nativeAudioNode.connect = ((connect) => {
        return (destination, output = 0, input = 0) => {
            destinations.set(destination, { input, output });
            if (destination instanceof AudioNode) {
                // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.
                return connect.call(nativeAudioNode, destination, output, input);
            }
            return connect.call(nativeAudioNode, destination, output);
        };
    })(nativeAudioNode.connect);
    nativeAudioNode.disconnect = ((disconnect) => {
        return (outputOrDestination, _output, _input) => {
            disconnect.apply(nativeAudioNode);
            if (outputOrDestination === undefined) {
                destinations.clear();
            }
            else if (destinations.has(outputOrDestination)) {
                destinations.delete(outputOrDestination);
                destinations.forEach(({ input, output }, dstntn) => {
                    nativeAudioNode.connect(dstntn, input, output);
                });
            }
        };
    })(nativeAudioNode.disconnect);
};
//# sourceMappingURL=/build/es2018/wrappers/audio-node-disconnect-method.js.map